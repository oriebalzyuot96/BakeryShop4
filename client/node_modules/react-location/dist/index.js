'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var React = _interopDefault(require('react'));

function _typeof(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      _defineProperty(target, key, source[key]);
    });
  }

  return target;
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  }
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

function _iterableToArrayLimit(arr, i) {
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

function encode(obj, pfx) {
	var k, i, tmp, str='';

	for (k in obj) {
		if ((tmp = obj[k]) !== void 0) {
			if (Array.isArray(tmp)) {
				for (i=0; i < tmp.length; i++) {
					str && (str += '&');
					str += encodeURIComponent(k) + '=' + encodeURIComponent(tmp[i]);
				}
			} else {
				str && (str += '&');
				str += encodeURIComponent(k) + '=' + encodeURIComponent(tmp);
			}
		}
	}

	return (pfx || '') + str;
}

function toValue(mix) {
	var str = decodeURIComponent(mix);
	if (str === 'true') return true;
	if (str === 'false') return false;
	return (+str * 0 === 0) ? (+str) : str;
}

function decode(str) {
	var tmp, k, out={}, arr=str.split('&');

	while (tmp = arr.shift()) {
		tmp = tmp.split('=');
		k = tmp.shift();
		if (out[k] !== void 0) {
			out[k] = [].concat(out[k], toValue(tmp.shift()));
		} else {
			out[k] = toValue(tmp.shift());
		}
	}

	return out;
}

// Most of these utilities have been respectfully
// copied or modified from @reach/router by Ryan Florence
// and their licenses have been included in this project.
// Thanks Ryan!
function getLocation(source) {
  return _objectSpread({}, source.location, {
    state: source.history.state,
    id: source.history.state && source.history.state.id || 'initial'
  });
}

function createHistory(source) {
  var listeners = [];
  var location = getLocation(source);
  var transitioning = false;

  var resolveTransition = function resolveTransition() {};

  return {
    get location() {
      return location;
    },

    get transitioning() {
      return transitioning;
    },

    _onTransitionComplete: function _onTransitionComplete() {
      transitioning = false;
      resolveTransition();
    },
    listen: function listen(listener) {
      listeners.push(listener);

      var popstateListener = function popstateListener() {
        location = getLocation(source);
        listener({
          location: location,
          action: 'POP'
        });
      };

      source.addEventListener('popstate', popstateListener);
      return function () {
        source.removeEventListener('popstate', popstateListener);
        listeners = listeners.filter(function (fn) {
          return fn !== listener;
        });
      };
    },
    _navigate: function _navigate(to) {
      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          state = _ref.state,
          _ref$replace = _ref.replace,
          replace = _ref$replace === void 0 ? false : _ref$replace;

      state = _objectSpread({}, state, {
        id: "".concat(Date.now()) // try...catch iOS Safari limits to 100 pushState calls

      });

      try {
        if (transitioning || replace) {
          source.history.replaceState(state, null, to);
        } else {
          source.history.pushState(state, null, to);
        }
      } catch (e) {
        source.location[replace ? 'replace' : 'assign'](to);
      }

      location = getLocation(source);
      transitioning = true;
      var transition = new Promise(function (resolve) {
        resolveTransition = resolve;
      }); // setTimeout here to ensure that any unsubs have run before we try and notify them

      setTimeout(function () {
        listeners.forEach(function (listener) {
          return listener({
            location: location,
            action: 'PUSH'
          });
        });
      }, 1);
      return transition;
    }
  };
}
function createMemorySource() {
  var initialPathname = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '/';
  var index = 0;
  var stack = [{
    pathname: initialPathname,
    search: '',
    hash: ''
  }];
  var states = [];
  return {
    get location() {
      return stack[index];
    },

    addEventListener: function addEventListener() {},
    removeEventListener: function removeEventListener() {},
    history: {
      get entries() {
        return stack;
      },

      get index() {
        return index;
      },

      get state() {
        return states[index];
      },

      pushState: function pushState(state, _, href) {
        var _href$split = href.split('?'),
            _href$split2 = _slicedToArray(_href$split, 2),
            pathname = _href$split2[0],
            _href$split2$ = _href$split2[1],
            search = _href$split2$ === void 0 ? '' : _href$split2$;

        var hash = pathname.includes('#') ? pathname.split('#').reverse()[0] : '';
        index += 1;
        stack.push({
          pathname: pathname,
          search: search,
          href: href,
          hash: hash
        });
        states.push(state);
      },
      replaceState: function replaceState(state, _, href) {
        var _href$split3 = href.split('?'),
            _href$split4 = _slicedToArray(_href$split3, 2),
            pathname = _href$split4[0],
            _href$split4$ = _href$split4[1],
            search = _href$split4$ === void 0 ? '' : _href$split4$;

        var hash = pathname.includes('#') ? pathname.split('#').reverse()[0] : '';
        stack[index] = {
          pathname: pathname,
          search: search,
          href: href,
          hash: hash
        };
        states[index] = state;
      }
    }
  };
}

function trimSlashes(str) {
  return str.replace(/(^\/+|\/+$)/g, '');
}
function resolve(to, base) {
  to = String(to);

  if (startsWith(to, '/')) {
    return to;
  }

  var toSegments = segmentize(to);
  var baseSegments = segmentize(base);

  if (toSegments[0] === '') {
    return base;
  }

  if (!startsWith(toSegments[0], '.')) {
    var pathname = baseSegments.concat(toSegments).join('/');
    return (base === '/' ? '' : '/') + pathname;
  }

  var allSegments = baseSegments.concat(toSegments);
  var segments = [];

  for (var i = 0, l = allSegments.length; i < l; i++) {
    var segment = allSegments[i];
    if (segment === '..') segments.pop();else if (segment !== '.') segments.push(segment);
  }

  return "/".concat(segments.join('/'));
}
function isMatch(path, pathname) {
  var pathSegments = segmentize(path);
  var pathnameSegments = segmentize(pathname);
  var isExact = pathSegments.length === pathnameSegments.length;
  var newBasePath = [];
  var params = {};
  var isMatched = pathSegments.every(function (segment, i) {
    if (segment === pathnameSegments[i]) {
      newBasePath[i] = pathnameSegments[i];
      return true;
    }

    if (startsWith(segment, ':') && pathnameSegments[i]) {
      var paramName = trimLeading(segment, ':');
      params[paramName] = pathnameSegments[i];
      newBasePath[i] = pathnameSegments[i];
      return true;
    }

    return false;
  });
  newBasePath = newBasePath.join('/');
  return isMatched ? {
    params: params,
    newBasePath: newBasePath,
    isExact: isExact
  } : false;
}
function startsWith(string, search) {
  return string.substring(0, search.length) === search;
}
function trimLeading(string, search) {
  return string.substring(string.indexOf(search) + search.length);
}
function segmentize(uri) {
  if (!uri) {
    return [];
  }

  return trimSlashes(uri).split('/');
}
function isModifiedEvent(e) {
  return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey);
}
function getResolvedBasepath(path, basepath) {
  return path === '/' ? basepath : "".concat(trimSlashes(basepath), "/").concat(trimSlashes(path));
}
function useForceUpdate() {
  var _React$useState = React.useState(0),
      _React$useState2 = _slicedToArray(_React$useState, 2),
      _ = _React$useState2[0],
      setCount = _React$useState2[1];

  var mountedRef = React.useRef();
  React.useEffect(function () {
    mountedRef.current = true;
    return function () {
      mountedRef.current = false;
    };
  }, []);
  return React.useCallback(function () {
    if (mountedRef.current) {
      setCount(function (old) {
        return old + 1;
      });
    }
  }, []);
}

var context = React.createContext(); // Detect if we're in the DOM

var isDOM = Boolean(typeof window !== 'undefined' && window.document && window.document.createElement); // This is the default history object if none is defined

var globalHistory = createHistory(isDOM ? window : createMemorySource());

var LocationRoot = function LocationRoot(_ref) {
  var children = _ref.children,
      userHistory = _ref.history,
      userBasepath = _ref.basepath;
  // If this is the first history, create it using the userHistory or browserHistory
  var historyRef = React.useRef(userHistory || globalHistory);
  var forceUpdate = useForceUpdate();
  var history = historyRef.current; // Let's get at some of the nested data on the history object

  var _history$location = history.location,
      pathname = _history$location.pathname,
      fullHash = _history$location.hash,
      search = _history$location.search,
      state = _history$location.state,
      id = _history$location.id,
      _onTransitionComplete = history._onTransitionComplete; // eslint-disable-next-line react-hooks/exhaustive-deps

  state = React.useMemo(function () {
    return state;
  }, [JSON.stringify(state)]); // Get the hash without the bang

  var hash = fullHash.split('#').reverse()[0]; // The default basepath for the entire Location

  var basepath = userBasepath || '/'; // Parse the query params into an object

  var query = React.useMemo(function () {
    var query = decode(search.substring(1)); // Try to parse any query params that might be json

    Object.keys(query).forEach(function (key) {
      try {
        query[key] = JSON.parse(query[key]);
      } catch (err) {//
      }
    });
    return query;
  }, [search]); // Start off with fresh params at the top level

  var params = React.useMemo(function () {
    return {};
  }, []);
  var href = pathname + (hash ? "#".concat(hash) : '') + search; // Build our context value

  var contextValue = {
    basepath: basepath,
    pathname: pathname,
    hash: hash,
    params: params,
    query: query,
    search: search,
    state: state,
    href: href,
    id: id,
    history: history
  };
  var historyListenerRef = React.useRef(); // Subscribe to the history, even before the component mounts

  if (!historyListenerRef.current) {
    // Update this component any time history updates
    historyListenerRef.current = history.listen(forceUpdate);
  } // Before the component unmounts, unsubscribe from the history


  React.useEffect(function () {
    return historyListenerRef.current;
  }, []); // After component update, mark the transition as complete

  React.useEffect(function () {
    _onTransitionComplete();
  });
  return React.createElement(context.Provider, {
    value: contextValue
  }, children);
}; // This is the main Location component that acts like a Provider


var LocationProvider = function LocationProvider(_ref2) {
  var children = _ref2.children,
      location = _ref2.location,
      rest = _objectWithoutProperties(_ref2, ["children", "location"]);

  if (location) {
    return React.createElement(context.Provider, {
      value: location
    }, children);
  }

  return React.createElement(LocationRoot, rest, children);
}; // This hook powers just about everything. It is also responsible for
// creating the navigate() function based on the depth at which the hook is used

var useLocation = function useLocation() {
  var contextValue = React.useContext(context);
  var forceUpdate = useForceUpdate();
  var query = contextValue.query,
      state = contextValue.state,
      history = contextValue.history,
      basepath = contextValue.basepath,
      pathname = contextValue.pathname,
      params = contextValue.params; // Make sure any components using this hook update when the
  // history changes

  React.useEffect(function () {
    return history.listen(forceUpdate);
  }, [forceUpdate, history]);
  var navigateRef = React.useRef();
  navigateRef.current = {
    history: history,
    basepath: basepath,
    query: query,
    state: state // Make the navigate function

  };
  var navigate = React.useCallback(function (to) {
    var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        queryUpdater = _ref3.query,
        stateUpdater = _ref3.state,
        replace = _ref3.replace,
        preview = _ref3.preview;

    // Allow query params and state to be updated with a function
    var resolvedQuery = typeof queryUpdater === 'function' ? queryUpdater(navigateRef.current.query) : queryUpdater;
    var resolvedState = typeof stateUpdater === 'function' ? stateUpdater(navigateRef.current.state) : stateUpdater; // If the query was updated, serialize all of the subkeys

    if (resolvedQuery) {
      Object.keys(resolvedQuery).forEach(function (key) {
        var val = resolvedQuery[key];

        if (_typeof(val) === 'object' && val !== 'null') {
          resolvedQuery[key] = JSON.stringify(val);
        }
      });
    } // Then stringify the query params for URL encoding


    var search = encode(resolvedQuery, '?'); // Construct the final href for the navigation

    var href = resolve(typeof to === 'function' ? to(params) : to, navigateRef.current.basepath) + (search === '?' ? '' : search); // If this is a preview, just return the final href

    if (preview) {
      return href;
    } // Otherwise, apply the navigation to the history


    return navigateRef.current.history._navigate(href, {
      state: resolvedState,
      replace: replace
    });
  }, []);
  var isMatch$$1 = React.useCallback(function (matchPath, from) {
    return isMatch(getResolvedBasepath(matchPath, from || basepath), pathname);
  }, [basepath, pathname]);
  return _objectSpread({}, contextValue, {
    navigate: navigate,
    isMatch: isMatch$$1
  });
};
var Location = function Location(_ref4) {
  var children = _ref4.children,
      render = _ref4.render,
      rest = _objectWithoutProperties(_ref4, ["children", "render"]);

  var location = useLocation(rest);

  if (children) {
    return children(location);
  }

  if (render) {
    return render(location);
  }

  return null;
};
var withLocation = function withLocation(Comp) {
  return function (props) {
    var location = useLocation();
    return React.createElement(Comp, _extends({}, props, {
      location: location
    }));
  };
}; // MatchFirst returns the first matching child Match component or
// any non-null non-Match component and renders only that component.
// Comparable to React-Locations Swtich component

var MatchFirst = function MatchFirst(_ref5) {
  var children = _ref5.children;
  var matchFirstRef = React.useRef();
  matchFirstRef.current = false;
  var comp;
  children = React.Children.toArray(children);

  _toConsumableArray(children.reverse()).forEach(function (child) {
    comp = child.type.__isMatch ? React.cloneElement(child, _objectSpread({}, child.props, {
      miss: comp,
      exact: child.props.path === '/'
    })) : child.type.__isRedirect ? React.cloneElement(child, _objectSpread({}, child.props, {
      miss: comp
    })) : child;
  });

  return comp;
}; // The Match component is used to match paths againts the location and
// render content for that match

var Match = function Match(_ref6) {
  var path = _ref6.path,
      routes = _ref6.routes,
      children = _ref6.children,
      render = _ref6.render,
      Comp = _ref6.component,
      _ref6$miss = _ref6.miss,
      miss = _ref6$miss === void 0 ? null : _ref6$miss,
      exact = _ref6.exact,
      rest = _objectWithoutProperties(_ref6, ["path", "routes", "children", "render", "component", "miss", "exact"]);

  // Use the location
  var locationValue = useLocation();
  var params = locationValue.params,
      isMatch$$1 = locationValue.isMatch; // See if the route is currently matched

  var match = React.useMemo(function () {
    return isMatch$$1(path);
  }, [isMatch$$1, path]);
  var newBasePath;

  if (match) {
    // If the route is a match, make sure we use
    // the newBasePath from the match. It contains
    // the interpolated path, free of route param
    // identifiers
    newBasePath = match.newBasePath;
  }

  var newParams = React.useMemo(function () {
    return _objectSpread({}, params, match ? match.params : {});
  }, [match, params]); // Update the contex to use hte new basePath and params

  var contextValue = React.useMemo(function () {
    return _objectSpread({}, locationValue, {
      basepath: newBasePath,
      params: newParams
    });
  }, [locationValue, newBasePath, newParams]); // Not a match? Return a miss

  if (!match || exact && !match.isExact) {
    return miss;
  }

  var renderProps = _objectSpread({}, contextValue, contextValue.params); // Support the render prop


  if (render) {
    children = render(renderProps);
  } // Support the component prop


  if (Comp) {
    children = React.createElement(Comp, _extends({}, renderProps, rest));
  } // Support child as a function


  if (typeof children === 'function') {
    children = children(renderProps);
  } // Support just children


  return React.createElement(context.Provider, {
    value: contextValue
  }, children);
};
Match.__isMatch = true; // The Match component is used to match paths againts the location and
// render content for that match

var Redirect = function Redirect(_ref7) {
  var from = _ref7.from,
      to = _ref7.to,
      query = _ref7.query,
      state = _ref7.state,
      _ref7$replace = _ref7.replace,
      replace = _ref7$replace === void 0 ? true : _ref7$replace,
      _ref7$miss = _ref7.miss,
      miss = _ref7$miss === void 0 ? null : _ref7$miss;
  // Use the location
  var locationValue = useLocation();
  var pathname = locationValue.pathname,
      navigate = locationValue.navigate,
      isMatch$$1 = locationValue.isMatch; // See if the route is currently matched

  var match = React.useMemo(function () {
    return !from || isMatch$$1(from);
  }, [from, isMatch$$1]);

  if (match && from === '/' && !match.isExact) {
    match = false;
  }

  React.useLayoutEffect(function () {
    if (match) {
      navigate(to, {
        query: query,
        state: state,
        replace: replace
      });
    }
  }, [match, navigate]);

  if (match) {
    return null;
  }

  return miss;
};
Redirect.__isRedirect = true;
function Link(_ref8) {
  var to = _ref8.to,
      query = _ref8.query,
      replace = _ref8.replace,
      state = _ref8.state,
      onClick = _ref8.onClick,
      target = _ref8.target,
      _ref8$style = _ref8.style,
      style = _ref8$style === void 0 ? {} : _ref8$style,
      _ref8$className = _ref8.className,
      className = _ref8$className === void 0 ? '' : _ref8$className,
      _ref8$getActiveProps = _ref8.getActiveProps,
      getActiveProps = _ref8$getActiveProps === void 0 ? function () {
    return {};
  } : _ref8$getActiveProps,
      activeType = _ref8.activeType,
      children = _ref8.children,
      rest = _objectWithoutProperties(_ref8, ["to", "query", "replace", "state", "onClick", "target", "style", "className", "getActiveProps", "activeType", "children"]);

  // Use the useLocation hook
  var location = useLocation();
  var navigate = location.navigate,
      pathname = location.pathname,
      href = location.href; // If this `to` is an external URL, make a normal a href

  if (typeof to === 'string') {
    try {
      var link = new URL(to);
      return React.createElement("a", _extends({
        href: link.href,
        target: target,
        style: style,
        className: className
      }, rest), children);
    } catch (e) {// if a path is not parsable by URL its a local relative path.
      // Proceed
    }
  } // Get the preview href for this link and its variations


  var linkHrefWithQuery = navigate(to, {
    query: query,
    state: state,
    replace: replace,
    preview: true,
    params: location.params
  });
  var linkHrefWithHash = linkHrefWithQuery.split('?')[0];
  var linkHref = linkHrefWithHash.split('#')[0]; // Detect if this link is active using the different activeType options

  var isCurrent;

  if (activeType === 'partial') {
    isCurrent = startsWith(href, linkHrefWithQuery);
  } else if (activeType === 'path') {
    isCurrent = pathname === linkHref;
  } else if (activeType === 'hash') {
    isCurrent = pathname === linkHrefWithHash;
  } else {
    isCurrent = href === linkHrefWithQuery;
  } // Get the active props


  var _ref9 = isCurrent ? getActiveProps(location) : {},
      _ref9$style = _ref9.style,
      activeStyle = _ref9$style === void 0 ? {} : _ref9$style,
      _ref9$className = _ref9.className,
      activeClassName = _ref9$className === void 0 ? '' : _ref9$className,
      activeRest = _objectWithoutProperties(_ref9, ["style", "className"]); // The click handler


  var handleClick = function handleClick(e) {
    if (onClick) onClick(e);

    if (!e.defaultPrevented && // onClick prevented default
    e.button === 0 && ( // ignore everything but left clicks
    !target || target === '_self') && // let browser handle "target=_blank" etc.
    !isModifiedEvent(e) // ignore clicks with modifier keys
    ) {
        e.preventDefault(); // All is well? Navigate!

        navigate(to, {
          query: query,
          state: state,
          replace: replace
        });
      }
  };

  return React.createElement("a", _extends({
    href: linkHrefWithQuery,
    target: target,
    onClick: handleClick,
    style: _objectSpread({}, style, activeStyle),
    className: [className, activeClassName].filter(Boolean).join(' ') || undefined
  }, rest, activeRest), children);
}

exports.createHistory = createHistory;
exports.createMemorySource = createMemorySource;
exports.globalHistory = globalHistory;
exports.LocationProvider = LocationProvider;
exports.useLocation = useLocation;
exports.Location = Location;
exports.withLocation = withLocation;
exports.MatchFirst = MatchFirst;
exports.Match = Match;
exports.Redirect = Redirect;
exports.Link = Link;
//# sourceMappingURL=index.js.map
